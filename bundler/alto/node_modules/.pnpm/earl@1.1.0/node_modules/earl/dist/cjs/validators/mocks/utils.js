"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.compareArgs = exports.formatCalledTimes = exports.formatTimes = exports.assertIsMock = void 0;
const index_js_1 = require("../../format/index.js");
const index_js_2 = require("../../isEqual/index.js");
const index_js_3 = require("../../mocks/index.js");
function assertIsMock(control) {
    if (!(0, index_js_3.isMockFn)(control.actual)) {
        const actualInline = (0, index_js_1.formatCompact)(control.actual);
        return control.fail({
            reason: `The value ${actualInline} is not a mock function, but it was expected to be a mock function.`,
        });
    }
}
exports.assertIsMock = assertIsMock;
function formatTimes(times) {
    return times === 1 ? 'once' : times === 2 ? 'twice' : `${times} times`;
}
exports.formatTimes = formatTimes;
function formatCalledTimes(mock) {
    return mock.calls.length === 0
        ? 'never called'
        : `called ${formatTimes(mock.calls.length)}`;
}
exports.formatCalledTimes = formatCalledTimes;
function compareArgs(control, actual, expected) {
    const actualInline = (0, index_js_1.formatCompact)(actual);
    const expectedInline = (0, index_js_1.formatCompact)(expected);
    control.assert({
        success: (0, index_js_2.isEqual)(actual, expected),
        reason: `The passed arguments ${actualInline} are not equal to ${expectedInline}, but were expected to be equal.`,
        negatedReason: `The passed arguments ${actualInline} are equal to ${expectedInline}, but were expected not to be equal.`,
        actual,
        expected,
    });
}
exports.compareArgs = compareArgs;
//# sourceMappingURL=utils.js.map
import { Control } from './Control.js';
import { formatCompact } from './format/index.js';
export class Matcher {
    constructor(representation, check) {
        this.representation = representation;
        this.check = check;
    }
    toString() {
        return this.representation;
    }
}
class Expectation {
    constructor(_value) {
        this._value = _value;
        this._negated = false;
    }
    get not() {
        if (this._negated) {
            throw new TypeError('Cannot apply .not modifier twice.');
        }
        this._negated = true;
        return this;
    }
    _getControl(name) {
        const functionName = this._negated
            ? `expect().not.${name}`
            : `expect().${name}`;
        return new Control({
            name: functionName,
            actual: this._value,
            isNegated: this._negated,
        });
    }
}
export function registerValidator(name, validator) {
    function execute(...args) {
        return validator(this._getControl(name), ...args);
    }
    Object.defineProperty(execute, 'name', { value: name, writable: false });
    Reflect.set(Expectation.prototype, name, execute);
}
const rawExpect = function expect(value) {
    return new Expectation(value);
};
const matchers = Object.create(null);
export function registerMatcher(name, check, format) {
    Reflect.set(matchers, name, (...args) => {
        const representation = format
            ? format(...args)
            : `${name}(${args.map((x) => formatCompact(x)).join(', ')})`;
        return new Matcher(representation, check(...args));
    });
}
export const expect = new Proxy(rawExpect, {
    get(target, name) {
        var _a;
        // we need this, because otherwise we cannot override length
        return (_a = Reflect.get(matchers, name)) !== null && _a !== void 0 ? _a : Reflect.get(target, name);
    },
});
//# sourceMappingURL=expect.js.map
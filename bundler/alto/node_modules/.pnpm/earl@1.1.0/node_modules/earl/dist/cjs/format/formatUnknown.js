"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatUnknown = void 0;
const expect_js_1 = require("../expect.js");
const getCanonicalType_js_1 = require("../isEqual/getCanonicalType.js");
const formatArrayEntries_js_1 = require("./formatArrayEntries.js");
const formatMapEntries_js_1 = require("./formatMapEntries.js");
const formatNumber_js_1 = require("./formatNumber.js");
const formatObjectEntries_js_1 = require("./formatObjectEntries.js");
const formatSetEntries_js_1 = require("./formatSetEntries.js");
const formatString_js_1 = require("./formatString.js");
const formatSymbol_js_1 = require("./formatSymbol.js");
const getComparedTypeName_js_1 = require("./getComparedTypeName.js");
const getRepresentation_js_1 = require("./getRepresentation.js");
const toLine_js_1 = require("./toLine.js");
function formatUnknown(value, sibling, options, valueStack, siblingStack) {
    const type = (0, getCanonicalType_js_1.getCanonicalType)(value);
    switch (type) {
        case 'null':
            return (0, toLine_js_1.toLine)('null');
        case 'undefined':
            return (0, toLine_js_1.toLine)('undefined');
        case 'boolean':
            return (0, toLine_js_1.toLine)(value ? 'true' : 'false');
        case 'string':
            return (0, toLine_js_1.toLine)((0, formatString_js_1.formatString)(value, options));
        case 'bigint':
            return (0, toLine_js_1.toLine)(`${value}n`);
        case 'number':
            return (0, formatNumber_js_1.formatNumber)(value, sibling, options);
        case 'symbol':
            return (0, formatSymbol_js_1.formatSymbol)(value, sibling);
    }
    if (value instanceof expect_js_1.Matcher) {
        if (!options.skipMatcherReplacement && value.check(sibling)) {
            return formatUnknown(sibling, null, options, siblingStack, []);
        }
        else {
            let line = `expect.${value.toString()}`;
            if (options.inline && line.length > options.maxLineLength) {
                // TODO: function name!
                line = 'expect.?';
            }
            return (0, toLine_js_1.toLine)(line);
        }
    }
    const selfIndex = valueStack.indexOf(value);
    if (selfIndex !== -1) {
        const dots = '.'.repeat(valueStack.length - selfIndex);
        return (0, toLine_js_1.toLine)(`<Circular ${dots}>`);
    }
    const items = [];
    const { typeName, isDifferentPrototype, isSameTypeName } = (0, getComparedTypeName_js_1.getComparedTypeName)(value, sibling, type, options.ignorePrototypes);
    if (typeName) {
        items.push(typeName);
    }
    if (isDifferentPrototype) {
        items.push('(different prototype)');
    }
    if (options.requireStrictEquality ||
        type === 'Promise' ||
        type === 'WeakMap' ||
        type === 'WeakSet' ||
        type === 'Function') {
        if (value !== sibling && isSameTypeName && !isDifferentPrototype) {
            items.push('(different)');
        }
    }
    if (type === 'Promise' || type === 'WeakMap' || type === 'WeakSet') {
        return (0, toLine_js_1.toLine)(items.join(' '));
    }
    if (type === 'Error' &&
        options.inline &&
        options.maxLineLength !== Infinity) {
        return (0, toLine_js_1.toLine)(`${typeName !== null && typeName !== void 0 ? typeName : ''}(${(0, formatString_js_1.formatString)(value.message, options)})`);
    }
    const representation = (0, getRepresentation_js_1.getRepresentation)(value, type, options);
    if (representation) {
        items.push(representation);
    }
    const entries = [];
    valueStack.push(value);
    siblingStack.push(sibling);
    if (type === 'Array') {
        entries.push(...(0, formatArrayEntries_js_1.formatArrayEntries)(value, sibling, options, valueStack, siblingStack));
    }
    else if (type === 'Set') {
        entries.push(...(0, formatSetEntries_js_1.formatSetEntries)(value, sibling, options, valueStack, siblingStack));
    }
    else if (type === 'Map') {
        entries.push(...(0, formatMapEntries_js_1.formatMapEntries)(value, sibling, options, valueStack, siblingStack));
    }
    entries.push(...(0, formatObjectEntries_js_1.formatObjectEntries)(value, sibling, options, valueStack, siblingStack));
    valueStack.pop();
    siblingStack.pop();
    const skipObjectIfEmpty = type === 'Date' ||
        type === 'Function' ||
        type === 'RegExp' ||
        type === 'String' ||
        type === 'Number' ||
        type === 'Boolean';
    if (entries.length === 0) {
        if (!skipObjectIfEmpty) {
            items.push(type === 'Array' ? '[]' : '{}');
        }
        return (0, toLine_js_1.toLine)(items.join(' '));
    }
    if (skipObjectIfEmpty) {
        items.push('&');
    }
    items.push(type === 'Array' ? '[' : '{');
    const beginning = items.join(' ');
    if (options.inline) {
        let jointEntries = entries.map((x) => x[1]).join(', ');
        if (jointEntries.length > options.maxLineLength) {
            jointEntries =
                entries.length === 1 ? '1 entry' : `${entries.length} entries`;
        }
        if (type === 'Array') {
            return (0, toLine_js_1.toLine)(`${beginning}${jointEntries}]`);
        }
        else {
            return (0, toLine_js_1.toLine)(`${beginning} ${jointEntries} }`);
        }
    }
    else {
        entries.unshift([0, beginning]);
        entries.push([0, type === 'Array' ? ']' : '}']);
        return entries;
    }
}
exports.formatUnknown = formatUnknown;
//# sourceMappingURL=formatUnknown.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.expect = exports.registerMatcher = exports.registerValidator = exports.Matcher = void 0;
const Control_js_1 = require("./Control.js");
const index_js_1 = require("./format/index.js");
class Matcher {
    constructor(representation, check) {
        this.representation = representation;
        this.check = check;
    }
    toString() {
        return this.representation;
    }
}
exports.Matcher = Matcher;
class Expectation {
    constructor(_value) {
        this._value = _value;
        this._negated = false;
    }
    get not() {
        if (this._negated) {
            throw new TypeError('Cannot apply .not modifier twice.');
        }
        this._negated = true;
        return this;
    }
    _getControl(name) {
        const functionName = this._negated
            ? `expect().not.${name}`
            : `expect().${name}`;
        return new Control_js_1.Control({
            name: functionName,
            actual: this._value,
            isNegated: this._negated,
        });
    }
}
function registerValidator(name, validator) {
    function execute(...args) {
        return validator(this._getControl(name), ...args);
    }
    Object.defineProperty(execute, 'name', { value: name, writable: false });
    Reflect.set(Expectation.prototype, name, execute);
}
exports.registerValidator = registerValidator;
const rawExpect = function expect(value) {
    return new Expectation(value);
};
const matchers = Object.create(null);
function registerMatcher(name, check, format) {
    Reflect.set(matchers, name, (...args) => {
        const representation = format
            ? format(...args)
            : `${name}(${args.map((x) => (0, index_js_1.formatCompact)(x)).join(', ')})`;
        return new Matcher(representation, check(...args));
    });
}
exports.registerMatcher = registerMatcher;
exports.expect = new Proxy(rawExpect, {
    get(target, name) {
        var _a;
        // we need this, because otherwise we cannot override length
        return (_a = Reflect.get(matchers, name)) !== null && _a !== void 0 ? _a : Reflect.get(target, name);
    },
});
//# sourceMappingURL=expect.js.map
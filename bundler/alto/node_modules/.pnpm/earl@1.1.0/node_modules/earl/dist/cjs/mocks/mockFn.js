"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isMockFn = exports.mockFn = void 0;
const index_js_1 = require("../isEqual/index.js");
const mockSymbol = Symbol('mock');
function mockFn(defaultImplementation) {
    let defaultSpec = {
        type: 'not-ready',
    };
    let oneTimeOverrides = [];
    let parameterOverrides = [];
    function mock(...args) {
        var _a;
        for (const override of parameterOverrides) {
            if ((0, index_js_1.isEqual)(args, override.args)) {
                parameterOverrides.splice(parameterOverrides.indexOf(override), 1);
                return runSpec(override.spec, args);
            }
        }
        const current = (_a = oneTimeOverrides.shift()) !== null && _a !== void 0 ? _a : defaultSpec;
        return runSpec(current, args);
    }
    mock[mockSymbol] = true;
    mock.calls = [];
    mock.isExhausted = function () {
        return oneTimeOverrides.length === 0 && parameterOverrides.length === 0;
    };
    mock.getOneTimeOverridesLength = function () {
        return oneTimeOverrides.length;
    };
    mock.getParameterOverridesLength = function () {
        return parameterOverrides.length;
    };
    function runSpec(spec, args) {
        switch (spec.type) {
            case 'return': {
                mock.calls.push({ args, result: { type: 'return', value: spec.value } });
                return spec.value;
            }
            case 'lazy-return': {
                const value = spec.value();
                mock.calls.push({ args, result: { type: 'return', value } });
                return value;
            }
            case 'throw': {
                mock.calls.push({ args, result: { type: 'throw', error: spec.error } });
                throw spec.error;
            }
            case 'exec': {
                try {
                    const value = spec.implementation(...args);
                    mock.calls.push({ args, result: { type: 'return', value } });
                    return value;
                }
                catch (error) {
                    mock.calls.push({ args, result: { type: 'throw', error } });
                    throw error;
                }
            }
            case 'not-ready': {
                if (parameterOverrides.length > 0) {
                    throw new Error('The mock function was called with arguments that do not match any of the parameter overrides and no default behavior has been provided.');
                }
                throw new TypeError('The mock function was called but no default behavior has been provided.');
            }
            default: {
                throw new Error('Unreachable case');
            }
        }
    }
    mock.reset = function () {
        defaultSpec = { type: 'not-ready' };
        oneTimeOverrides = [];
        parameterOverrides = [];
        if (defaultImplementation) {
            mock.executes(defaultImplementation);
        }
    };
    mock.returns = function (value) {
        defaultSpec = { type: 'return', value };
        return mock;
    };
    mock.returnsOnce = function (value) {
        oneTimeOverrides.push({ type: 'return', value });
        return mock;
    };
    mock.throws = function (error) {
        defaultSpec = { type: 'throw', error };
        return mock;
    };
    mock.throwsOnce = function (error) {
        oneTimeOverrides.push({ type: 'throw', error });
        return mock;
    };
    mock.executes = function (implementation) {
        defaultSpec = { type: 'exec', implementation };
        return mock;
    };
    mock.executesOnce = function (implementation) {
        oneTimeOverrides.push({ type: 'exec', implementation });
        return mock;
    };
    mock.resolvesTo = function (value) {
        defaultSpec = { type: 'return', value: Promise.resolve(value) };
        return mock;
    };
    mock.resolvesToOnce = function (value) {
        oneTimeOverrides.push({ type: 'return', value: Promise.resolve(value) });
        return mock;
    };
    mock.rejectsWith = function (error) {
        defaultSpec = { type: 'lazy-return', value: () => Promise.reject(error) };
        return mock;
    };
    mock.rejectsWithOnce = function (error) {
        oneTimeOverrides.push({
            type: 'lazy-return',
            value: () => Promise.reject(error),
        });
        return mock;
    };
    mock.given = function (...args) {
        return {
            returnsOnce(value) {
                parameterOverrides.push({ args, spec: { type: 'return', value } });
                return mock;
            },
            throwsOnce(error) {
                parameterOverrides.push({ args, spec: { type: 'throw', error } });
                return mock;
            },
            executesOnce(implementation) {
                parameterOverrides.push({
                    args,
                    spec: { type: 'exec', implementation },
                });
                return mock;
            },
            resolvesToOnce(value) {
                parameterOverrides.push({
                    args,
                    spec: { type: 'return', value: Promise.resolve(value) },
                });
                return mock;
            },
            rejectsWithOnce(error) {
                parameterOverrides.push({
                    args,
                    spec: { type: 'lazy-return', value: () => Promise.reject(error) },
                });
                return mock;
            },
        };
    };
    if (defaultImplementation) {
        mock.executes(defaultImplementation);
    }
    return mock;
}
exports.mockFn = mockFn;
function isMockFn(value) {
    return typeof value === 'function' && value[mockSymbol] === true;
}
exports.isMockFn = isMockFn;
//# sourceMappingURL=mockFn.js.map
import { registerValidator } from '../../expect.js';
import { formatCompact } from '../../format/index.js';
import { captureAsyncError, processError } from './errors.js';
registerValidator('toBeRejected', (control) => toBeRejectedWith(control));
registerValidator('toBeRejectedWith', toBeRejectedWith);
export async function toBeRejectedWith(control, errorClassOrMessage, message) {
    if (typeof control.actual === 'function') {
        return handleAsyncFunction(control, control.actual, errorClassOrMessage, message);
    }
    if (control.actual instanceof Promise) {
        return handlePromise(control, control.actual, errorClassOrMessage, message);
    }
    const actualInline = formatCompact(control.actual);
    return control.fail({
        reason: `The value ${actualInline} is neither a function nor a promise, but it was expected to be a function or a promise.`,
    });
}
async function handleAsyncFunction(control, 
// eslint-disable-next-line @typescript-eslint/ban-types
fn, errorClassOrMessage, message) {
    const { didThrow, error } = await captureAsyncError(() => fn());
    if (!didThrow) {
        return control.assert({
            success: false,
            reason: 'The async function call did not throw an error, but it was expected to.',
            negatedReason: '',
        });
    }
    processError(control, error, 'The async function call threw', errorClassOrMessage, message);
}
async function handlePromise(control, promise, errorClassOrMessage, message) {
    const { didThrow, error } = await captureAsyncError(() => promise);
    if (!didThrow) {
        return control.assert({
            success: false,
            reason: 'The promise was not rejected, but it was expected to be rejected.',
            negatedReason: '',
        });
    }
    processError(control, error, 'The promise was rejected with', errorClassOrMessage, message);
}
//# sourceMappingURL=toBeRejectedWith.js.map